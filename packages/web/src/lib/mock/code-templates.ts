/**
 * Code templates for the mock Rust C compiler project.
 * Provides initial file contents and line pools for code evolution.
 */

/** Initial file contents at trajectory start */
export const CODE_TEMPLATES: Record<string, string[]> = {
  "src/main.rs": [
    `use std::env;`,
    `use std::fs;`,
    `use std::process;`,
    ``,
    `mod lexer;`,
    `mod parser;`,
    `mod ast;`,
    `mod codegen;`,
    ``,
    `fn main() {`,
    `    let args: Vec<String> = env::args().collect();`,
    `    if args.len() < 2 {`,
    `        eprintln!("Usage: cc <input.c> -o <output>");`,
    `        process::exit(1);`,
    `    }`,
    ``,
    `    let input = &args[1];`,
    `    let source = fs::read_to_string(input)`,
    `        .unwrap_or_else(|err| {`,
    `            eprintln!("Error: {}", err);`,
    `            process::exit(1);`,
    `        });`,
    ``,
    `    let tokens = lexer::tokenize(&source);`,
    `    let ast = parser::parse(&tokens);`,
    `    let asm = codegen::generate(&ast);`,
    `    println!("{}", asm);`,
    `}`,
  ],
  "src/lexer.rs": [
    `use crate::types::Token;`,
    ``,
    `pub fn tokenize(source: &str) -> Vec<Token> {`,
    `    let mut tokens = Vec::new();`,
    `    let mut chars = source.chars().peekable();`,
    ``,
    `    while let Some(&ch) = chars.peek() {`,
    `        match ch {`,
    `            ' ' | '\\t' | '\\n' => { chars.next(); }`,
    `            '(' => { tokens.push(Token::LParen); chars.next(); }`,
    `            ')' => { tokens.push(Token::RParen); chars.next(); }`,
    `            '{' => { tokens.push(Token::LBrace); chars.next(); }`,
    `            '}' => { tokens.push(Token::RBrace); chars.next(); }`,
    `            ';' => { tokens.push(Token::Semi); chars.next(); }`,
    `            _ => { chars.next(); }`,
    `        }`,
    `    }`,
    `    tokens`,
    `}`,
  ],
  "src/parser.rs": [
    `use crate::ast::*;`,
    `use crate::types::Token;`,
    ``,
    `pub struct Parser {`,
    `    tokens: Vec<Token>,`,
    `    pos: usize,`,
    `}`,
    ``,
    `impl Parser {`,
    `    pub fn new(tokens: Vec<Token>) -> Self {`,
    `        Self { tokens, pos: 0 }`,
    `    }`,
    ``,
    `    fn peek(&self) -> &Token {`,
    `        self.tokens.get(self.pos).unwrap()`,
    `    }`,
    ``,
    `    fn advance(&mut self) -> &Token {`,
    `        let tok = &self.tokens[self.pos];`,
    `        self.pos += 1;`,
    `        tok`,
    `    }`,
    `}`,
    ``,
    `pub fn parse(tokens: &[Token]) -> Program {`,
    `    let mut parser = Parser::new(tokens.to_vec());`,
    `    parser.parse_program()`,
    `}`,
  ],
  "src/ast.rs": [
    `#[derive(Debug, Clone)]`,
    `pub enum Expr {`,
    `    Number(i64),`,
    `    Ident(String),`,
    `    BinOp(Box<Expr>, Op, Box<Expr>),`,
    `    UnaryOp(Op, Box<Expr>),`,
    `    Call(String, Vec<Expr>),`,
    `}`,
    ``,
    `#[derive(Debug, Clone)]`,
    `pub enum Stmt {`,
    `    Return(Expr),`,
    `    Expr(Expr),`,
    `    VarDecl(String, Expr),`,
    `}`,
    ``,
    `#[derive(Debug, Clone)]`,
    `pub struct Program {`,
    `    pub functions: Vec<Function>,`,
    `}`,
  ],
  "src/codegen.rs": [
    `use crate::ast::*;`,
    ``,
    `pub struct Emitter {`,
    `    out: String,`,
    `    label_id: usize,`,
    `}`,
    ``,
    `impl Emitter {`,
    `    pub fn new() -> Self {`,
    `        Self { out: String::new(), label_id: 0 }`,
    `    }`,
    ``,
    `    fn emit(&mut self, line: &str) {`,
    `        self.out.push_str(line);`,
    `        self.out.push('\\n');`,
    `    }`,
    ``,
    `    fn new_label(&mut self) -> String {`,
    `        self.label_id += 1;`,
    `        format!(".L{}", self.label_id)`,
    `    }`,
    `}`,
    ``,
    `pub fn generate(program: &Program) -> String {`,
    `    let mut emitter = Emitter::new();`,
    `    emitter.out`,
    `}`,
  ],
  "src/types.rs": [
    `#[derive(Debug, Clone, PartialEq)]`,
    `pub enum Token {`,
    `    LParen, RParen,`,
    `    LBrace, RBrace,`,
    `    Semi,`,
    `    Number(i64),`,
    `    Ident(String),`,
    `    Eof,`,
    `}`,
  ],
  "build.sh": [
    `#!/usr/bin/env bash`,
    `set -euo pipefail`,
    `cargo build --release`,
    `cp target/release/cc ./cc`,
  ],
  "Cargo.toml": [
    `[package]`,
    `name = "cc"`,
    `version = "0.1.0"`,
    `edition = "2021"`,
  ],
};

/** Lines that can be inserted at various phases of development */
export const LINE_POOLS: Record<string, { early: string[]; mid: string[]; late: string[] }> = {
  "src/main.rs": {
    early: [
      `mod types;`,
      ``,
      `    let output = args.iter()`,
      `        .position(|arg| arg == "-o")`,
      `        .and_then(|idx| args.get(idx + 1))`,
      `        .map(|val| val.as_str())`,
      `        .unwrap_or("a.out");`,
    ],
    mid: [
      `mod ir;`,
      `mod optimizer;`,
      ``,
      `    let ir = ir::lower(&ast);`,
      `    let optimized = optimizer::run(&ir);`,
      `    let asm = codegen::generate_from_ir(&optimized);`,
    ],
    late: [
      `mod regalloc;`,
      `mod backend;`,
      ``,
      `    let allocated = regalloc::allocate(&optimized);`,
      `    let binary = backend::x86::emit(&allocated);`,
    ],
  },
  "src/lexer.rs": {
    early: [
      `            '+' => { tokens.push(Token::Plus); chars.next(); }`,
      `            '-' => { tokens.push(Token::Minus); chars.next(); }`,
      `            '*' => { tokens.push(Token::Star); chars.next(); }`,
    ],
    mid: [
      `            '0'..='9' => {`,
      `                let mut num = String::new();`,
      `                while let Some(&digit) = chars.peek() {`,
      `                    if digit.is_ascii_digit() { num.push(digit); chars.next(); }`,
      `                    else { break; }`,
      `                }`,
      `                tokens.push(Token::Number(num.parse().unwrap()));`,
      `            }`,
    ],
    late: [
      `            '&' => {`,
      `                chars.next();`,
      `                if chars.peek() == Some(&'&') { tokens.push(Token::AmpAmp); chars.next(); }`,
      `                else { tokens.push(Token::Amp); }`,
      `            }`,
    ],
  },
  "src/parser.rs": {
    early: [
      `    fn expect(&mut self, tok: &str) -> Result<(), String> {`,
      `        let next = self.advance();`,
      `        if next.matches(tok) { Ok(()) } else { Err(format!("expected {}", tok)) }`,
      `    }`,
    ],
    mid: [
      ``,
      `    fn parse_function(&mut self) -> Function {`,
      `        let ret_ty = self.parse_type();`,
      `        let name = self.expect_ident();`,
      `        self.expect("(").unwrap();`,
      `        let params = self.parse_params();`,
      `        self.expect(")").unwrap();`,
      `        let body = self.parse_block();`,
      `        Function { name, ret_ty, params, body }`,
      `    }`,
    ],
    late: [
      ``,
      `    fn parse_expr(&mut self) -> Expr {`,
      `        self.parse_assignment()`,
      `    }`,
    ],
  },
  "src/codegen.rs": {
    early: [
      `    fn gen_function(&mut self, func: &Function) {`,
      `        self.emit(&format!("    .globl {}", func.name));`,
      `        self.emit(&format!("{}:", func.name));`,
      `        self.emit("    pushq %rbp");`,
      `        self.emit("    movq %rsp, %rbp");`,
      `    }`,
    ],
    mid: [
      ``,
      `    fn gen_expr(&mut self, expr: &Expr) {`,
      `        match expr {`,
      "            Expr::Number(val) => self.emit(&format!(\"    movl ${}, %eax\", val)),",
      `            _ => {}`,
      `        }`,
      `    }`,
    ],
    late: [
      ``,
      `    fn gen_stmt(&mut self, stmt: &Stmt) {`,
      `        match stmt {`,
      `            Stmt::Return(expr) => {`,
      `                self.gen_expr(expr);`,
      `                self.emit("    ret");`,
      `            }`,
      `            _ => {}`,
      `        }`,
      `    }`,
    ],
  },
  "src/types.rs": {
    early: [
      `    Plus, Minus, Star, Slash,`,
      `    Comma,`,
      `    KwInt, KwReturn,`,
    ],
    mid: [
      `    KwIf, KwElse, KwWhile, KwFor,`,
      `    Eq, EqEq, Bang, BangEq,`,
    ],
    late: [
      `    Amp, AmpAmp, Pipe, PipePipe,`,
      `    Arrow, Dot,`,
      `    KwStruct, KwTypedef, KwSizeof,`,
    ],
  },
};

/** New files that appear during trajectory evolution */
export const NEW_FILE_TEMPLATES: Record<string, { phase: number; content: string[] }> = {
  "src/ir.rs": {
    phase: 0.33,
    content: [
      `use crate::ast::*;`,
      ``,
      `#[derive(Debug, Clone)]`,
      `pub enum IRNode {`,
      `    Const(i64),`,
      `    BinOp(Op, Box<IRNode>, Box<IRNode>),`,
      `    Load(String),`,
      `    Store(String, Box<IRNode>),`,
      `    Ret(Box<IRNode>),`,
      `}`,
      ``,
      `pub fn lower(program: &Program) -> Vec<IRNode> {`,
      `    let mut nodes = Vec::new();`,
      `    nodes`,
      `}`,
    ],
  },
  "src/optimizer.rs": {
    phase: 0.55,
    content: [
      `use crate::ir::*;`,
      ``,
      `pub fn run(nodes: &[IRNode]) -> Vec<IRNode> {`,
      `    let mut out = nodes.to_vec();`,
      `    constant_fold(&mut out);`,
      `    out`,
      `}`,
      ``,
      `fn constant_fold(nodes: &mut Vec<IRNode>) {`,
      `    for node in nodes.iter_mut() {`,
      `        if let IRNode::BinOp(op, left, right) = node {`,
      `            if let (IRNode::Const(val_a), IRNode::Const(val_b)) = (left.as_ref(), right.as_ref()) {`,
      `                *node = IRNode::Const(val_a + val_b);`,
      `            }`,
      `        }`,
      `    }`,
      `}`,
    ],
  },
};
